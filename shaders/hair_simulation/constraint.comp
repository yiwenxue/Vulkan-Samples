#define MAX_STRANDS
#define STRAND_LENGTH
#define GRID_DIMENSION
#define WORK_GROUP_SIZE
#define CONSTRAINT_ITERATION

struct Particle {
    vec4 pos;
    vec4 oldpos;
};

struct Strand {
    vec4 pos;
    vec4 oldpos;
};

layout(std430, binding = 0) buffer InitialStrands {
    Strand initialStrands[];
};

layout(std430, binding = 0) buffer Strands {
    Strand inStrands[];
};

layout(std430, binding = 1) buffer AeroGrid {
    vec4 aerogrid[];
};

layout(std430, binding = 2) buffer VelGrid {
    vec4 velgrid[];
};

layout(set = 0, binding = 0) uniform CameraUBO {
    mat4 view;
    mat4 proj;
} camera;


layout(set = 0, binding = 1) uniform Time {
    float deltaTime;
    float totalTime;
};

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

bool isMovable(vec4 point) {
    return point.w > 0.0;
}

void solveDistanceConstanint(int index0, int index1, float targetDistance) {
    vec4 p0 = inStrands[index0];
	vec4 p1 = inStrands[index1];

	vec3 delta = p1.xyz - p0.xyz;
	float distance = max(length(delta), 1e-7);
	float stretching = 1 - targetDistance / distance;
	delta = delta * stretching;
	vec2 multiplier = vec2(0.0, 0.0);

    if(isMovable(p0)) {
	    multiplier = isMovable(p1) ? vec2(0.5, 0.5) : vec2(1.0, 0.0);
	}
	else {
	    multiplier =  isMovable(p1) ? vec2(0.0, 1.0) : vec2(0.0, 0.0);
	}

    if (dot(multiplier, multiplier) > 0)) {
        inStrands[index0].xyz += multiplier[0] * delta;
	    inStrands[index1].xyz -= multiplier[1] * delta;
    }
}
    
}

void main() {
	uint threadIdx = gl_GlobalInvocationID.x; // strand id;

    if (threadIdx > MAX_STRANDS) return;

    int strandPtr = threadIdx * STRAND_LENGTH;
    int pointPtr = strandPtr;

    // constraint loop
    for (int i = 0; i < CONSTRAINT_ITERATION; i++) {
        // length
        pointPtr = strandPtr;
        for (int j = 1; j < STRAND_LENGTH; j++) {
            float d = distance(initialStrands[pointPtr].pos, initialStrands[pointPtr-1].pos);
            solveDistanceConstanint(pointPtr, pointPtr-1, d);
            pointPtr += 1;
        }
        // orentation
        for (int j = 1; j < STRAND_LENGTH; j++) {

        }
        // global length ?
        // collision
        for (int j = 1; j < STRAND_LENGTH; j++) {

        }
    }

    barrier();


}